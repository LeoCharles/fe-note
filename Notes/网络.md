# 网络

+ [阮一峰互联网协议入门](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)

## 五层模型

互联网协议五层模型：

1. 应用层(HTTP, FTP, SMTP, DNS)： 文件传输，电子邮件，文件服务，虚拟终端
2. 传输层(TCP, UDP)：建立"端口到端口"的通信
3. 网络层(IP, ARP)：为数据包选择路由，建立"主机到主机"的通信
4. 数据链路层(PPP)： 封装成帧及错误检测
5. 物理层：二进制数据形式在物理媒体上传输

每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则，大家都遵守的规则，就叫做"协议"（protocol）。

### 物理层

物理层就是把电脑通过双绞线、电缆、光缆、无线电波等方式连接起来的物理手段。作用是负责传送 0 和 1 的比特流。

### 数据链路层

单纯的 0 和 1 没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是数据链路层的功能，它在物理层的上方，确定了 0 和 1 的分组方式。

以太网（Ethernet）规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。

以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做 MAC 地址。

### 网络层

网络层的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。规定网络地址的协议，叫做 IP 协议。它所定义的地址，就被称为 IP 地址。

网络层出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。

因为 IP 数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的 MAC 地址，另一个是对方的IP地址。通常情况下，对方的 IP 地址是已知的，但是我们不知道它的 MAC 地址。所以，我们需要一种机制，能够从 IP 地址得到 MAC 地址。

如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。如果两台主机在同一个子网络，那么我们可以用 ARP 协议，得到对方的 MAC 地址。

### 传输层

有了 MAC 地址和 IP 地址，我们已经可以在互联网上任意两台主机上建立通信。

但是同一台主机上有许多程序都需要用到网络，比如，一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？

因此，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用，这个参数就叫做"端口"（port）———— 0 到 65535 之间的一个整数。

传输层的功能，就是建立"端口到端口"的通信。相比之下，网络层的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。

UDP 协议：

它的格式几乎就是在数据前面，加上端口号。

UDP 协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为了解决这个问题，TCP 协议诞生了。

TCP 协议：

TCP 协议非常复杂，可以近似认为，它就是有确认机制的 UDP 协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。

三次握手握手建立连接以及断开连接时的四次挥手。

### 应用层

应用层的作用，就是规定应用程序的数据格式。举例来说，TCP 协议可以为各种各样的程序传递数据，比如 Email、WWW、FTP 等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了应用层。

![网络协议](/img/wangluoxieyi.png)

DNS 协议可以帮助我们，将网址转换成 IP 地址。

## HTTP

HTTP 协议是基于 TCP/IP 的应用层协议，它的模式非常简单，就是客户端发起请求，服务器响应请求。

HTTP 请求/响应由三部分组成：

+ 通用头部：包含请求方法、请求地址、状态码和 HTTP 协议版本
+ 请求/响应头部：包含一系列的键值对
+ 请求/响应实体：请求时，除了头部，还有请求实体，比如请求参数。响应实体中，就是放服务端需要传给客户端的内容。

HTTP 协议是个无状态协议，不会保存状态。

### 常见状态码

2XX 成功：

+ 200 ok，表示从客户端发出来的请求在服务端被正确处理。
+ 204 No Content，表示请求成功，但响应报文不含实体的主体部分。
+ 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，要求请求方重置内容。
+ 206 Partial Content，进行范围请求。

3XX 重定向：

+ 301 moved permanently，永久重定向，表示资源已被分配到新的 URL。
+ 302 found， 临时性重定向，表示资源临时被分配了新的 URL。
+ 303 see other，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源。
+ 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况。
+ 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。

4XX 客户端错误：

+ 400 bad request，请求报文存在语法错误
+ 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
+ 403 forbidden，表示对请求资源的访问被服务器拒绝
+ 404 not found，表示在服务器上没有找到请求的资源

5XX 服务器错误：

+ 500 internal sever error，表示服务器端在执行请求时发生了错误
+ 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
+ 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### Post 和 Get 的区别

+ Get 请求能缓存，Post 不能
+ Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会
+ Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术
+ URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的
+ Post 支持更多的编码类型且不对数据类型限制

## 从输入 URL 到页面加载完成的过程

应用层(DNS解析成IP，发送HTTP请求) => 传输层(建立TCP连接) => 网络层(IP寻址) => 数据链路层(封装成帧) => 物理层(利用物理介质传输比特流)

1. 首先做 DNS 查询，通过域名查询到具体的 IP。
2. 接下来是发送 HTTP 请求，三次 TCP 握手建立连接。应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。
3. 如果是 HTTPS 协议，在 TCP 握手结束后会进行 TLS 握手，加密数据。然后数据包在数据链路层封装成帧，最后就是物理层的传输。
4. 请求数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上。假设服务端会响应一个 HTML 文件。
5. 首先浏览器会判断响应状态码是什么，如果是 200 那就继续解析，如果 300 的话会进行重定向，如果 400 或 500 的话就会报错。
6. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。
7. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。遇到 script 标签，会判断是否存在 async(会并行进行下载并执行 JS)或者 defer(defer会先下载文件，然后等待 HTML 解析完成后顺序执行)。如果没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件。
8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件（jQ中的 ready 事件）。页面上所有的资源（图片，音频，视频等）被加载以后才会触发 load 事件。
9. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西。
10. 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上。
